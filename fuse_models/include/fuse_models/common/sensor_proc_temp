inline bool processAccel2DWithCovariance(const std::string& source, const fuse_core::UUID& device_id,
                                         const geometry_msgs::AccelWithCovarianceStamped& acceleration,
                                         const fuse_core::Loss::SharedPtr& loss, const std::string& target_frame,
                                         const std::vector<size_t>& indices, const tf2_ros::Buffer& tf_buffer,
                                         const bool validate, fuse_core::Transaction& transaction,
                                         const ros::Duration& tf_timeout = ros::Duration(0, 0))
{
  // Make sure we actually have work to do
  if (indices.empty())
  {
    return false;
  }

  geometry_msgs::AccelWithCovarianceStamped transformed_message;
  if (target_frame.empty())
  {
    transformed_message = acceleration;
  }
  else
  {
    transformed_message.header.frame_id = target_frame;

    if (!transformMessage(tf_buffer, acceleration, transformed_message, tf_timeout))
    {
      ROS_WARN_STREAM_DELAYED_THROTTLE(10.0, "Failed to transform acceleration message with stamp "
                                                 << acceleration.header.stamp << ". Cannot create constraint.");
      return false;
    }
  }

  // Create the acceleration variables
  auto acceleration_linear =
      fuse_variables::AccelerationLinear2DStamped::make_shared(acceleration.header.stamp, device_id);
  acceleration_linear->x() = transformed_message.accel.accel.linear.x;
  acceleration_linear->y() = transformed_message.accel.accel.linear.y;

  // Create the full mean vector and covariance for the constraint
  fuse_core::Vector2d accel_mean;
  accel_mean << transformed_message.accel.accel.linear.x, transformed_message.accel.accel.linear.y;

  fuse_core::Matrix2d accel_covariance;
  accel_covariance << transformed_message.accel.covariance[0], transformed_message.accel.covariance[1],
      transformed_message.accel.covariance[6], transformed_message.accel.covariance[7];

  // Build the sub-vector and sub-matrices based on the requested indices
  fuse_core::VectorXd accel_mean_partial(indices.size());
  fuse_core::MatrixXd accel_covariance_partial(accel_mean_partial.rows(), accel_mean_partial.rows());

  populatePartialMeasurement(accel_mean, accel_covariance, indices, accel_mean_partial, accel_covariance_partial);

  if (validate)
  {
    try
    {
      validatePartialMeasurement(accel_mean_partial, accel_covariance_partial);
    }
    catch (const std::runtime_error& ex)
    {
      ROS_ERROR_STREAM_THROTTLE(10.0, "Invalid partial linear acceleration measurement from '"
                                          << source << "' source: " << ex.what());
      return false;
    }
  }

  // Create the constraint
  auto linear_accel_constraint = fuse_constraints::AbsoluteAccelerationLinear2DStampedConstraint::make_shared(
      source, *acceleration_linear, accel_mean_partial, accel_covariance_partial, indices);

  linear_accel_constraint->loss(loss);

  transaction.addVariable(acceleration_linear);
  transaction.addConstraint(linear_accel_constraint);
  transaction.addInvolvedStamp(acceleration.header.stamp);

  return true;
}